#!/usr/bin/bash

. utils.sh
require_collection_id "$@"

stage=$STAGE/collection/$id
  
if [[ $# -ge 2 ]]; then     # pass source URL and optional format for testing
  url=$2
  format=${3:-rdf}
else                        # get source URL from collections database
  collections=$STAGE/collection/collections.json
  [[ -f $collections ]] || error "Missing $collections, please update list of collections!"

  name=$(jq -r ".[]|select(.uri==\"$uri\")|.name" $collections)
  [[ -n "$name" ]] || error "Collection $id not found!"
  echo "Name: $name"

  # create collection.json and collection.nt

  about=$stage/collection.json
  mkdir -p $stage

  jq -r ".[]|select(.uri==\"$uri\")" $collections > $about
  npm run --silent -- jsonld2rdf -c collection-context.json $about > $stage/collection.nt

  url=$(jq -r ".access?.url // \"\"" $about)
  format=$(jq -r ".access?.format // \"\" | split(\"/\")[-1]" $about)
fi

echo $url

if [[ -z "$url" ]]; then
   format="rdf"
fi

# TODO: support OAI-PMH for LIDO/XML
if [[ "$format" != "rdf" ]]; then
  error "Only RDF data supported so far, got $format"
fi

echo "Receive $format data from $url"

inbox=$STAGE/inbox/$id
download_dir=$stage/download

rm -rf $download_dir
mkdir -p $download_dir


if [[ $url == *doi.org* ]]; then
  ./download-from-repository.py $url $download_dir
elif [[ $url == http* ]]; then
  wget -q $url --directory-prefix $download_dir
elif [[ -d $inbox ]]; then
  cp $inbox/* $download_dir
else
  error "No valid source $url"
fi

# TODO: support LIDO/XML via repository
./extract-rdf.py $download_dir $stage/triples.nt
./transform-rdf $stage/triples.nt     # includes validation
